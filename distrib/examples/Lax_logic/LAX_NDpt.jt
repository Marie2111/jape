/* $Id$ */

FONTS "Konstanz"
INITIALISE displaystyle box

CLASS BAG ‚
CONSTANT false * true efq ¹1 ¹2 i1 i2 val i
CLASS VARIABLE x y z c d u v
CLASS FORMULA A B C P Q R S p q r s

INFIX 	10R		:
LEFTFIX	20		è .
LEFTFIX	20		ä .
LEFTFIX	20		û .
OUTFIX case of end
OUTFIX let be in end

PREFIX	50 		×
INFIX 	80L		@
INFIX		100R	ç
INFIX		120L		¦
INFIX		140L		ë
PREFIX	200		Â
JUXTFIX	300
SUBSTFIX	400 

BIND x SCOPE P IN èx . P
BIND x SCOPE P IN äx . P
BIND x SCOPE P IN ûx . P
BIND x SCOPE Q IN let x be P in Q end

/* INITIALISE autoAdditiveLeft	true allow rules to be stated without an explicit left context */
INITIALISE interpretpredicates	true /* allow predicate syntax ... */

TACTIC ForwardCut (n,Rule)
	SEQ cut (ForwardUncut n rule)

TACTIC ForwardUncut (n,Rule)
	(LETGOALPATH G (WITHARGSEL Rule) (GOALPATH G n) (WITHHYPSEL hyp) (GOALPATH G) NEXTGOAL)

TACTIC ForwardOrBackward (Forward, n, Rule) IS 
	WHEN	(LETHYP 
				_P 
                          	(ALT	(Forward n Rule)
					(WHEN	(LETARGSEL _Q 
                                                              (Fail (Rule is not applicable to assumption ' _P ' with argument ' _Q '))
							)
							(Fail (Rule is not applicable to assumption ' _P '))
					)
                                )
			)
			(ALT	(WITHSELECTIONS Rule)
                   		(WHEN	(LETARGSEL _P
                                                	(Fail (Rule is not applicable with argument ' _P '))
                                              	)
						(Fail (Rule is not applicable))
				)
           		)
   
TACTIC "è-E tac" IS ForwardOrBackward ForwardCut 0 "è-E"
TACTIC "ä-I tac" IS "ä-I" /* this because it can be overridden, and we refer to it in ItL_hits.j */
TACTIC "×-Etac" IS ForwardOrBackward ForwardUncut 0 "×-E"
	
MENU Rules IS
    ENTRY "ç-I"
    ENTRY "¦-I"	
    ENTRY "ë-I(L)"	IS ForwardOrBackward ForwardCut 0 "ë-I(L)"
    ENTRY "ë-I(R)"	IS ForwardOrBackward ForwardCut 0 "ë-I(R)"
    ENTRY "Â-I"
    ENTRY "è-I"
    ENTRY "ä-I"		IS "ä-I tac"
    ENTRY "×-I"
    SEPARATOR
    ENTRY "ç-E"		IS ForwardOrBackward ForwardCut 1 "ç-E" 
    ENTRY "¦-E(L)"	IS ForwardOrBackward ForwardCut 0 "¦-E(L)"
    ENTRY "¦-E(R)" 	IS ForwardOrBackward ForwardCut 0 "¦-E(R)"
    ENTRY "ë-E"		IS ForwardOrBackward ForwardUncut 0 "ë-E"	
    ENTRY "Â-E"		IS ForwardOrBackward ForwardCut 0 "Â-E"	
    ENTRY "è-E"		IS "è-E tac"	
    ENTRY "ä-E"		IS ForwardOrBackward ForwardUncut 0 "ä-E"
	ENTRY "×-E" IS "×-Etac"
    SEPARATOR
    ENTRY hyp
END

TACTIC Fail(x) IS (SEQ (ALERT x) FAIL)

SEQUENT IS BAG æ FORMULA

RULE cut(B) IS FROM ‚ æ B AND ‚,B æ C INFER ‚ æ C
RULE thin(A) IS FROM ‚ æ C INFER ‚,A æ C

RULE "ç-E"(A)			IS FROM ‚ æ p:A AND ‚ æ q:AçB INFER ‚ æ p@q:B
RULE "¦-E(L)"(B)		IS FROM ‚ æ r:A ¦ B INFER ‚ æ ¹1(r):A
RULE "¦-E(R)"(A)		IS FROM ‚ æ r:A ¦ B INFER ‚ æ ¹2(r):B
RULE "ë-E"(A,B, OBJECT y, OBJECT z) WHERE y NOTIN ‚ AND z NOTIN ‚
					IS FROM ‚ æ r:A ë B AND ‚,y:A æ p:C AND ‚,z:B æ q:C 
					INFER ‚ æ case r of (i1(y)çp, i2(z)çq) end:C
RULE "è-E"(B)			IS FROM ‚ æ p:èx.A(x) INFER ‚ æ p@B:A(B)
RULE "ä-E"(OBJECT c, OBJECT z) WHERE FRESH c AND c NOTIN äx.A(x) AND z NOTIN ‚
					IS FROM ‚ æ r:äx.A(x) AND ‚,z:A(c) æ p:C INFER ‚ æ case r of i(x,z)çp end: C
RULE "×-E"(OBJECT z) WHERE z NOTIN ‚ 
					IS FROM ‚ æ p:×A  AND ‚,z:A æ q:×B INFER ‚ æ let z be p in q end: ×B

RULE "ç-I"(OBJECT z) WHERE z NOTIN ‚
					IS FROM ‚,z:A æ p:B INFER ‚ æ ûz.p:AçB
RULE "¦-I"			IS FROM ‚ æ p:A AND ‚ æ q:B INFER ‚ æ (p,q):A ¦ B
RULE "ë-I(L)"(B)		IS FROM ‚ æ p:A INFER ‚ æ i1(p):A ë B
RULE "ë-I(R)"(A)		IS FROM ‚ æ p:B INFER ‚ æ i2(p):A ë B
/* RULE "Â-I"(B)		IS FROM A æ B ¦ ÂB INFER ÂA */
RULE "è-I"(OBJECT c) WHERE FRESH c AND x NOTIN ‚
					IS FROM ‚ æ p:A(c) INFER ‚ æ ûx.p:èx.A(x)
RULE "ä-I"(B)			IS FROM ‚ æ p:A(B) INFER ‚ æ i(B,p):äx.A(x)
RULE "×-I"			IS FROM ‚ æ p:A INFER ‚ æ val(p):×A

RULE hyp(A) 			IS INFER ‚,p:A æ p:A
RULE "true-I" 			IS INFER ‚ æ *:true
RULE "false-E" 			IS FROM ‚ æ p:false INFER ‚ æ efq(p):A

AUTOMATCH hyp

STRUCTURERULE IDENTITY    hyp
STRUCTURERULE CUT            cut
STRUCTURERULE WEAKEN     thin

HYPHIT	p:P     æ q:P	IS hyp       
HYPHIT	p:P¦Q æ q:R	IS ALT	(SEQ "¦-E(L)" (WITHHYPSEL hyp))
                                           		(SEQ "¦-E(R)" (WITHHYPSEL hyp))
                                           		(SEQ (ForwardCut 0 "¦-E(L)") (ForwardCut 0 "¦-E(R)"))
HYPHIT	p:PçQ  æ q:R	IS ForwardCut 1 "ç-E"
HYPHIT	p:PëQ  æ q:R	IS ForwardUncut 0 "ë-E"
HYPHIT	p:ÂÂP   æ q:Q	IS ForwardCut 0 "Â-E"
HYPHIT	p:èx.P æ q:Q	IS "è-E tac"
HYPHIT	p:äx.P æ q:Q	IS ForwardUncut 0 "ä-E"
HYPHIT 	P:×A  æ q:B	IS "×-Etac"

CONCHIT	p:Q¦R	IS "¦-I"
CONCHIT	p:QëR	IS ALT (SEQ "ë-I(L)" hyp) (SEQ "ë-I(R)" hyp)
CONCHIT	p:QçR	IS "ç-I"      
CONCHIT	p:ÂQ	IS "Â-I"       
CONCHIT	p:èx.Q	IS "è-I"  
CONCHIT	p:äx.Q	IS "ä-I tac"  
CONCHIT 	p:×A 	IS "×-I"

CONSTANT cheese wine port claret dessert brie stilton

CONJECTUREPANEL "Conjectures"
	THEOREM INFER u1:èx.èy.cheese(x)¦wine(y) ç (×dessert(x,y)), 
		u2:×cheese(brie), u3:×cheese(stilton), u4:×wine(port), u5:×wine(claret) æ _p:äx.äy.×dessert(x,y)
 
END
