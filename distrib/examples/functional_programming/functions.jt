/*

	A game of functions and lists
	Bernard Sufrin & Richard Bornat
	$Id$
	$Author$
	$Date$
*/


FONTS   "Konstanz"
SEQUENT IS BAG Ê FORMULA 

INFIX   1000    1000    È
INFIX   1100    1100    Á
INFIX   1500    1500    ¶
INFIX   1600    1600    Î
PREFIX                  ¬
INFIX   2000    2000    =, ≥, ≤, ≠, <, >
INFIX   2500    2500    +, -
INFIX   2600    2600    *, /
INFIX   2700    2700    ^

LEFTFIX Ë .
LEFTFIX ‰ .

CLASS    VARIABLE u, v, w, x, y, z
CLASS    FORMULA A, B, C, D, P, S, T, U, V, W, X, Y, Z
CONSTANT Ÿ
 
BIND    x SCOPE P IN ‰ x . P
BIND    x SCOPE P IN Ë x . P

USE     "equality.j"

INFIXC    4010 4000 :
INFIXC    3000 3010 ++
INFIXC    2800 2800 •
INFIXC    2900 2900 ª, Ù
OUTFIX   › ﬁ

CLASS FORMULA H, J
CONSTANT none, one, IF, true, false, if, sel, pair,
	 fst,  snd, id, cat, rcat, rev, nil, rev2, fold,
	 map,  filter, zip, swap 


MENU  Rules IS
      SEPARATOR
      
      RULE "ÊË"(OBJECT xs') WHERE FRESH xs'
	   FROM  AA[xs\xs']
	   INFER Ë xs . AA

      RULE "ËÊ"(B,OBJECT xs)
	   FROM   Ë xs . AA
	   INFER  AA[xs\B]

END

RULE    listinduction (B,  OBJECT xs, OBJECT ys, OBJECT x, OBJECT vs) 
WHERE   FRESH xs, ys, x 
FROM    AA[vs\nil] 
AND     AA[vs\›xﬁ] 
AND     AA[vs\xs], AA[vs\ys] Ê AA[vs\xs++ys] 
INFER   AA[vs \ B]

THEORY  Function IS
	RULES	IF
	ARE	IF true X Y	= X
	AND	IF false X Y	= Y
	END
	RULE	if		IS	if P (F, G) X   = IF (P X) (F X) (G X)
	RULE	"•"		IS	(F • G) X		= F(G X)
	RULE	ª		IS	(FªG) X		= (F X, G X)
	RULE	Ù		IS	(FÙG)(X,Y)	= (F X, G Y)
	RULE	id		IS	id X			= X
	RULE	fst		IS	fst(X,Y)		= X
	RULE	snd		IS	snd(X,Y)		= Y
	RULE	swap		IS	swap(X,Y)		= (Y,X)
END

MENU    Rules IS
        SEPARATOR
        ENTRY "list induction" IS 
        WHEN 
        (LETSUBSTSEL 
         (_Abase[_xvar\_Asel], 
          listinduction _Asel
         ),
         JAPE(fail(Please select an induction formula)))
END

MENU    Rules IS
        SEPARATOR
	RULE    BoolCases(B,OBJECT v)
		FROM  AA[v\true]
		AND   AA[v\false]
		INFER AA[v\B]

END

THEORY  List IS

	RULE	none IS	none X	= nil
	RULE	one	IS	one X	= ›Xﬁ

	RULE	cat	IS	cat = fold (++) nil

	RULES	rev
	ARE	rev nil		= nil
	AND	rev ›Xﬁ		= ›X ﬁ
	AND	rev (Xs++Ys)	= rev Ys ++ rev Xs
	END

	RULES	++
	ARE	nil++Ys		= Ys
	AND	Xs++nil		= Xs
	AND	(Xs++Ys)++ZS	= Xs++(Ys++ZS)
	END

	RULES	map
	ARE	map F nil			= nil
     	AND	map F ›Xﬁ		= ›F Xﬁ
	AND	map F (Xs++Ys)	= map F Xs ++ map F Ys
	END

	RULE filter IS filter P = cat • map (if P (one, none))

	RULES	zip
	ARE	zip(nil, nil)			= nil
	AND	zip(›Xﬁ, ›Yﬁ)			= ›(X,Y)ﬁ
	AND  zip(Xs++Xs', Ys++Ys')	= zip (Xs,Ys)++zip(Xs',Ys')
	END

	RULES fold (OBJECT A, OBJECT B, OBJECT C)
	ARE	fold F Z nil		= Z
	AND  fold F Z ›Xﬁ	= X
	AND  FROM F A (F B C) = F (F A B) C AND F A Z = A AND F Z B = B
		INFER fold F Z (Xs++Ys)	= F (fold F Z Xs) (fold F Z Ys)
	END

/*	RULE fold'0 IS fold F Z nil		= Z
	RULE fold'1 IS  fold F Z ›Xﬁ	= X
	RULE fold'2(OBJECT x, OBJECT y, OBJECT z) WHERE FRESH x,y,z
		IS  FROM F x (F y z) = F (F x y) z INFER fold F Z (Xs++Ys)	= F (fold F Z Xs) (fold F Z Ys)
	TACTIC fold IS ALT(fold'1, fold'2, fold'3)
*/
	RULE rev2 IS rev2 = fold rcat nil • map one
	
	RULE rcat IS rcat Xs Ys = Ys ++ Xs
	
	RULE ":" IS X:Xs = ›Xﬁ ++ Xs
END

CONSTANT ref, ins, del, move, L, R
THEORY  Reflect IS
	RULE	ref		IS 	ref					= (revÙrev) • swap
	RULE	ins		IS 	ins X (Xs,Ys)			= (Xs ++ ›Xﬁ, Ys)
	RULE	del		IS 	del  (Xs ++ ›Xﬁ, Ys)		= (Xs, Ys)
	RULE	move	IS 	move (Xs ++ ›Xﬁ, Ys)	= (Xs, ›Xﬁ ++ Ys)
	RULE	L		IS 	L F					= ref • F • ref
	RULE	R		IS 	R F					= F
END

CONJECTUREPANEL "List Conjectures" IS

        PREFIXBUTTON    "Apply"     IS apply
        PREFIXBUTTON    "Unfold"  IS apply UnfoldOneSel
        PREFIXBUTTON    "Fold"   IS apply FoldOneSel
        /* PREFIXBUTTON    "Unfold .." IS apply UnfoldSel
             PREFIXBUTTON    "Fold  .."  IS apply FoldSel
          */

        THEOREMS    ListThms
        ARE     rev • rev       = id
        AND     rev2            = rev
        AND     map F (xs++ys)  = map F xs ++ map F ys
/*      AND     
                associative F,
	        unit        F i
	        Ê
	        fold F i (xs++ys) = F(fold F i xs, fold F i ys) 
*/
END

        THEOREMS    FunctionThms
        ARE     swap • swap             = id
        AND     swap • (FÙG) • swap     = GÙF
        AND     (FÙG) • (HªJ)           = (F • H)ª(G • J)
        AND     idÙid                   = id
        AND     (FÙG) • (HÙJ)           = (F • H)Ù (G • J)
        AND     F  • id                 = F
        AND     F                       = id • F
        END

        THEOREMS    Associativity
        ARE         (F • G) • H = F • (G • H)
        END


        THEOREMS  Composition(J,H,F,G)
        ARE
                J • H = id,     H • F = H • G Ê F=G
        AND
                J • H = id,     F • J = G • J Ê F=G
        AND
                J • J = id, J • F • J = J • G • J Ê F=G
        END

        THEOREMS    ReflectThms
        ARE         ref • ref = id
        AND         del • ins X = id
        AND         R F • R G = R (F • G)
        AND         L F • L G = L (F • G)
        AND         G • L F = L G Ê L G • F = G
        END


END

TACTIC Auto IS
ALT
( List, ListThms, Function, FunctionThms, Reflect, ReflectThms
)

TACTICPANEL "Functions and Operators" 
        PREFIXBUTTON    "Unfold"  IS apply UnfoldOneSel
        PREFIXBUTTON    "Fold"   IS apply FoldOneSel
        /* PREFIXBUTTON    "Unfold .." IS apply UnfoldSel
             PREFIXBUTTON    "Fold  .."  IS apply FoldSel
          */
        BUTTON          "Unfold ?" IS apply Unfold Auto
        /* BUTTON          "Fold  ?"   IS apply Fold Auto */
        PREFIXBUTTON    "Apply"     IS apply

	ENTRY           ":"
	ENTRY           "•"   
	ENTRY           "Ù"   
	ENTRY           "ª"   
	ENTRY           "++"
	ENTRY           "cat"   
	ENTRY           "del"
	ENTRY           "filter"
	ENTRY           "fold"
	ENTRY           "fst" 
	ENTRY           "if"      
	ENTRY           "id"   
	ENTRY           "ins"
	ENTRY           "map"
	ENTRY           "move"
	ENTRY           "none" 
	ENTRY           "one"  
	ENTRY           "rcat"
	ENTRY           "ref"
	ENTRY           "rev"  
	ENTRY           "rev2"
	ENTRY           "snd"  
	ENTRY           "swap" 
	ENTRY           "zip"
	ENTRY           L
	ENTRY           R
END



/*
	Tactics
*/

TACTIC  mousebutton3(X)   IS ALT()
TACTIC  findbutton(X)     IS ALT()
TACTIC  cutbutton(X)      IS ALT()

MENU    "Edit" 
	RADIOBUTTON applyconjectures IS
		"Apply both conjectures and theorems" 	IS true
	AND	"Apply only theorems " 				IS false
   	INITIALLY false
 	END
	RADIOBUTTON displaystyle IS
		"Box display" 	IS box
	AND	"Tree display" 	IS tree
	INITIALLY box
	END
END





