/*

	A game of functions and lists
	Bernard Sufrin & Richard Bornat
	$Id$
	$Author$
	$Date$
*/


FONTS   "Konstanz"

USE     "equality.j"

INFIXC    4010 4000 :
INFIXC    3000 3010 ++
INFIXC    2800 2800 •
INFIXC    2900 2900 ª, Ù
OUTFIX   › ﬁ

CLASS VARIABLE v
CLASS FORMULA C, H, J, P
CONSTANT none, one, IF, true, false, if, sel, pair,
	 fst,  snd, id, cat, rcat, rev, rev2, fold,
	 map,  filter, zip, swap 


MENU  Rules IS
      SEPARATOR
      
      RULE "ÊË"(OBJECT xs') WHERE FRESH xs'
	   FROM  A[xs\xs']
	   INFER Ë xs . A

      RULE "ËÊ"(B,OBJECT xs)
	   FROM   Ë xs . A
	   INFER  A[xs\B]

END

RULE listinduction (B,  OBJECT x, OBJECT xs, OBJECT ys, OBJECT v)  WHERE FRESH x, xs, ys IS
	FROM  A[v\›ﬁ] AND A[v\›xﬁ] AND A[v\xs], A[v\ys] Ê A[v\xs++ys] 
	INFER  A[v \ B]

THEORY  Function IS
	RULES	IF
	ARE	IF true X Y	= X
	AND	IF false X Y	= Y
	END
	RULE	if		IS	if P (F, G) X   = IF (P X) (F X) (G X)
	RULE	"•"		IS	(F • G) X		= F(G X)
	RULE	ª		IS	(FªG) X		= (F X, G X)
	RULE	Ù		IS	(FÙG)(X,Y)	= (F X, G Y)
	RULE	id		IS	id X			= X
	RULE	fst		IS	fst(X,Y)		= X
	RULE	snd		IS	snd(X,Y)		= Y
	RULE	swap		IS	swap(X,Y)		= (Y,X)
END

MENU    Rules IS
	SEPARATOR
        
	ENTRY "list induction" IS 
		WHEN (LETSUBSTSEL (_A, WITHSUBSTSEL(listinduction)),
         	          JAPE(fail(Please select one or more instances of a sub-formula on which to perform induction))
         	         )
END

MENU    Rules IS
        SEPARATOR
	RULE    BoolCases(B,OBJECT x)
		FROM  A[x\true]
		AND   A[x\false]
		INFER A[x\B]

END

THEORY  List IS

	RULE	none IS	none X	= ›ﬁ
	RULE	one	IS	one X	= ›Xﬁ

	RULE	cat	IS	cat = fold (++) ›ﬁ

	RULES	rev
	ARE	rev ›ﬁ		= ›ﬁ
	AND	rev ›Xﬁ		= ›X ﬁ
	AND	rev (Xs++Ys)	= rev Ys ++ rev Xs
	END

	RULES	++
	ARE	›ﬁ++Ys		= Ys
	AND	Xs++›ﬁ		= Xs
	AND	(Xs++Ys)++ZS	= Xs++(Ys++ZS)
	END

	RULES	map
	ARE	map F ›ﬁ			= ›ﬁ
     	AND	map F ›Xﬁ		= ›F Xﬁ
	AND	map F (Xs++Ys)	= map F Xs ++ map F Ys
	END

	RULE filter IS filter P = cat • map (if P (one, none))

	RULES	zip
	ARE	zip(›ﬁ, ›ﬁ)			= ›ﬁ
	AND	zip(›Xﬁ, ›Yﬁ)			= ›(X,Y)ﬁ
	AND  zip(Xs++Xs', Ys++Ys')	= zip (Xs,Ys)++zip(Xs',Ys')
	END

	RULES fold (OBJECT A, OBJECT B, OBJECT C)
	ARE	fold F Z ›ﬁ		= Z
	AND  fold F Z ›Xﬁ	= X
	AND  FROM F A (F B C) = F (F A B) C AND F A Z = A AND F Z B = B
		INFER fold F Z (Xs++Ys)	= F (fold F Z Xs) (fold F Z Ys)
	END

/*	RULE fold'0 IS fold F Z ›ﬁ		= Z
	RULE fold'1 IS  fold F Z ›Xﬁ	= X
	RULE fold'2(OBJECT x, OBJECT y, OBJECT z) WHERE FRESH x,y,z
		IS  FROM F x (F y z) = F (F x y) z INFER fold F Z (Xs++Ys)	= F (fold F Z Xs) (fold F Z Ys)
	TACTIC fold IS ALT(fold'1, fold'2, fold'3)
*/
	RULE rev2 IS rev2 = fold rcat ›ﬁ • map one
	
	RULE rcat IS rcat Xs Ys = Ys ++ Xs
	
	RULE ":" IS X:Xs = ›Xﬁ ++ Xs
END

CONSTANT ref, ins, del, move, L, R
THEORY  Reflect IS
	RULE	ref		IS 	ref					= (revÙrev) • swap
	RULE	ins		IS 	ins X (Xs,Ys)			= (Xs ++ ›Xﬁ, Ys)
	RULE	del		IS 	del  (Xs ++ ›Xﬁ, Ys)		= (Xs, Ys)
	RULE	move	IS 	move (Xs ++ ›Xﬁ, Ys)	= (Xs, ›Xﬁ ++ Ys)
	RULE	L		IS 	L F					= ref • F • ref
	RULE	R		IS 	R F					= F
END

CONJECTUREPANEL "List Conjectures" IS

        PREFIXBUTTON    "Apply"     IS apply
        PREFIXBUTTON    "Unfold"  IS apply UnfoldOneSel
        PREFIXBUTTON    "Fold"   IS apply FoldOneSel
        /* PREFIXBUTTON    "Unfold .." IS apply UnfoldSel
             PREFIXBUTTON    "Fold  .."  IS apply FoldSel
          */

        THEOREMS    ListThms
        ARE     rev • rev       = id
        AND     rev2            = rev
        AND     map F (xs++ys)  = map F xs ++ map F ys
/*      AND     
                associative F,
	        unit        F i
	        Ê
	        fold F i (xs++ys) = F(fold F i xs, fold F i ys) 
*/
END

        THEOREMS    FunctionThms
        ARE     swap • swap             = id
        AND     swap • (FÙG) • swap     = GÙF
        AND     (FÙG) • (HªJ)           = (F • H)ª(G • J)
        AND     idÙid                   = id
        AND     (FÙG) • (HÙJ)           = (F • H)Ù (G • J)
        AND     F  • id                 = F
        AND     F                       = id • F
        END

        THEOREMS    Associativity
        ARE         (F • G) • H = F • (G • H)
        END


        THEOREMS  Composition(J,H,F,G)
        ARE
                J • H = id,     H • F = H • G Ê F=G
        AND
                J • H = id,     F • J = G • J Ê F=G
        AND
                J • J = id, J • F • J = J • G • J Ê F=G
        END

        THEOREMS    ReflectThms
        ARE         ref • ref = id
        AND         del • ins X = id
        AND         R F • R G = R (F • G)
        AND         L F • L G = L (F • G)
        AND         G • L F = L G Ê L G • F = G
        END


END

TACTIC Auto IS
ALT
( List, ListThms, Function, FunctionThms, Reflect, ReflectThms
)

TACTICPANEL "Functions and Operators" 
        PREFIXBUTTON    "Unfold"  IS apply UnfoldOneSel
        PREFIXBUTTON    "Fold"   IS apply FoldOneSel
        /* PREFIXBUTTON    "Unfold .." IS apply UnfoldSel
             PREFIXBUTTON    "Fold  .."  IS apply FoldSel
          */
        BUTTON          "Unfold ?" IS apply Unfold Auto
        /* BUTTON          "Fold  ?"   IS apply Fold Auto */
        PREFIXBUTTON    "Apply"     IS apply

	ENTRY           ":"
	ENTRY           "•"   
	ENTRY           "Ù"   
	ENTRY           "ª"   
	ENTRY           "++"
	ENTRY           "cat"   
	ENTRY           "del"
	ENTRY           "filter"
	ENTRY           "fold"
	ENTRY           "fst" 
	ENTRY           "if"      
	ENTRY           "id"   
	ENTRY           "ins"
	ENTRY           "map"
	ENTRY           "move"
	ENTRY           "none" 
	ENTRY           "one"  
	ENTRY           "rcat"
	ENTRY           "ref"
	ENTRY           "rev"  
	ENTRY           "rev2"
	ENTRY           "snd"  
	ENTRY           "swap" 
	ENTRY           "zip"
	ENTRY           L
	ENTRY           R
END



/*
	Tactics
*/

TACTIC  mousebutton3(X)   IS ALT()
TACTIC  findbutton(X)     IS ALT()
TACTIC  cutbutton(X)      IS ALT()

MENU    "Edit" 
	RADIOBUTTON applyconjectures IS
		"Apply both conjectures and theorems" 	IS true
	AND	"Apply only theorems " 				IS false
   	INITIALLY false
 	END
	RADIOBUTTON displaystyle IS
		"Box display" 	IS box
	AND	"Tree display" 	IS tree
	INITIALLY box
	END
END





